
花20000000可以让LexBurner的账号解封，得到19260817点社会信用。
花2000000可以让杏回归，得到18741515点社会信用。
花200000可以给东雪莲上10个月总督，得到11451419点社会信用。
花20000可以让女孩不用在厕所生孩，得到8101919点社会信用。
花2000可以去华东理工大学买一副耳机，得到889464点社会信用。
花500可以尽情嘴臭一顿€€£，得到500000点社会信用~~，并被禁赛1年~~。
花200可以让985学生买一副VR眼镜在厕所求导，得到364364点社会信用。
花20可以愉快地度过一个疯狂星期四，得到996007点心情。
以上每个项目只能最多消费一次，社会信用可以叠加，你现在有N元，请问你能得到的最大社会信用是多少？

输入格式
一行，给出一个整数N。

输出格式
一行，一个整数，回答你能得到的最大社会信用。

输入输出样例
输入 #1复制

1919810
输出 #1复制

21307166
#include <iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
//本题直接dfs深度搜索最大值即可
 
typedef long long ll;
ll ans = 0;
ll vis[66];
ll a[66] = { 0,200,500,2000,20000,200000,2000000,20000000};
ll b[66] = { 0,364364, 500000 ,889464 ,8101919 ,11451419 ,18741515 ,19260817 };
void dfs(ll n, ll sum)//n表示当前的钱，sum表示信用和
{
    ans = max(ans, sum);//取信用和最大值
    int i = 0;
    for (i = 1; i <= 7; i++)
    {
        if (n >= a[i] && vis[i] == 0)
        {
            vis[i] = 1;
            dfs(n - a[i], sum + b[i]);
            vis[i] = 0;//回溯
        }
    }
}
int main()
{
    ll n = 0;
    cin >> n;
    dfs(n, 0);
    cout << ans;
    return 0;

