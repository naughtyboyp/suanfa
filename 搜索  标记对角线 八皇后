题目描述
一个如下的 6 \times 66×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。



上面的布局可以用序列 2\ 4\ 6\ 1\ 3\ 52 4 6 1 3 5 来描述，第 ii 个数字表示在第 ii 行的相应位置有一个棋子，如下：

行号 1\ 2\ 3\ 4\ 5\ 61 2 3 4 5 6

列号 2\ 4\ 6\ 1\ 3\ 52 4 6 1 3 5

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。
并把它们以上面的序列方法输出，解按字典顺序排列。
请输出前 33 个解。最后一行是解的总个数。

输入格式
一行一个正整数 nn，表示棋盘是 n \times nn×n 大小的。

输出格式
前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

输入输出样例
输入 #1复制
6
输出 #1复制
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
说明/提示
【数据范围】
对于 100\%100% 的数据，6 \le n \le 136≤n≤13。

题目翻译来自NOCOW。

USACO Training Section 1.5
#include <stdio.h>
#include <string.h>
#include<iostream>
#include<algorithm>
#pragma warning(disable:4996)
using namespace std;
int k = 0;//计算答案个数
 
int place[20];//下标表示行，内容表示列
int cow[20];//列
int d1[20];//上对角线标记方法  下标 行 - 列 + 7    内容 为 1 表示  这个对角线被标记 
int d2[20];//下对角线标记方法   下标  行 + 列
//回溯的意义在于要求出 所有的解
 
void print(int n)
{
    k++;//能到这里说明有解
    if (k <= 3)
    {
        int i = 0;
        for (i = 1; i <= n; i++)//一共n行
        {
            printf("%d ", place[i]);
        }
        printf("\n");
    }
}
void ans(int h, int n)//h表示行，n表示一共n行
{
    int i = 0;
    for (i = 1; i <= n; i++)//i表示第i列
    {
        //已知具体的一个点，该点所在对角线的点的值都有相同的值  行-列+ 7 
        //那么标记对角线就OK了
        //上图
        if (cow[i] == 0 && d1[i - h + 7] == 0 && d2[i + h] == 0)//如果h行i列未被标记 说明可以放
        {
            place[h] = i;//下标表示h行  内容表示 i列
            cow[i] = 1;//标记第i列
            d1[i - h + 7] = 1;//标记上对角线
            d2[i + h] = 1;//标记下对角线
            if (h < n)//当不是最后一行的时候，继续探索
            {
                ans(h + 1, n);
            }
            else//最后一行打印答案
            {
                print(n);
            }
            cow[i] = 0;//回溯
            d1[i - h + 7] = 0;
            d2[i + h] = 0;
        }
    }
}
 
 
int main()
{
    int n = 0;
    cin >> n;
    ans(1, n);
    printf("%d", k);
    return 0;
}
