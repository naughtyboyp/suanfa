P1010 [NOIP1998 普及组] 幂次方
提交
59.51k
通过
38.41k
时间限制
1.00s
内存限制
125.00MB
提交答案
加入题单
题目提供者
CCF_NOI
难度
普及-
历史分数
100
 提交记录  查看题解
标签
NOIp 普及组
1998
进入讨论版
相关讨论
推荐题目
 展开
题目描述
任何一个正整数都可以用 22 的幂次方表示。例如 137=2^7+2^3+2^0137=2 
7
 +2 
3
 +2 
0
 。

同时约定方次用括号来表示，即 a^ba 
b
  可表示为 a(b)a(b)。

由此可知，137137 可表示为 2(7)+2(3)+2(0)2(7)+2(3)+2(0)

进一步：

7= 2^2+2+2^07=2 
2
 +2+2 
0
  ( 2^12 
1
  用 22 表示)，并且 3=2+2^03=2+2 
0
 。

所以最后 137137 可表示为 2(2(2)+2+2(0))+2(2+2(0))+2(0)2(2(2)+2+2(0))+2(2+2(0))+2(0)。

又如 1315=2^{10} +2^8 +2^5 +2+11315=2 
10
 +2 
8
 +2 
5
 +2+1

所以 13151315 最后可表示为 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)。

输入格式
一行一个正整数 nn。

输出格式
符合约定的 nn 的 0, 20,2 表示（在表示中不能有空格）。

输入输出样例
输入 #1复制
1315
输出 #1复制
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
说明/提示
【数据范围】

对于 100\%100% 的数据，1 \le n \le 2 \times {10}^41≤n≤2×10 
4
 。




#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include <iostream>
#pragma warning(disable:4996) 
using namespace std;
//总结 本题就是  二进制， 递归
//熟悉一下递归就好了   
//先用数组存个二进制  下标表示位数，内容表示幂
//然后从高往低  输出每个数
//最后一位 时不用输出加号  懂我意思吧
//本题更熟悉递归了  
void search(int n)
{
    int temp = n;
    int k = 0;//表示有k个数要相加
    int p = 0;//记录幂
    int a[66] = { 0 };
    while (temp)
    {
        if (temp & 1)
        {
            a[++k] = p;
        }
        p++;
        temp >>= 1;
    }
    while (k)//输出k个 2的幂次方 相加呀
    {
        if (a[k] < 3)//2的幂次方小于3 那肯定直接干啊
        {
            if (a[k] == 1 && k > 1)//说明k不是最后一位
            {
                cout << "2+";
            }
            else if (a[k] == 1)//能到这里说明 k == 1 输出的是最后一位
            {
                cout << "2";
            }
            if ((a[k] == 0 || a[k] == 2) && k > 1)//同上呀宝
            {
                printf("2(%d)+", a[k]);
            }
            else if (a[k] == 0 || a[k] == 2)
            {
                printf("2(%d)", a[k]);
            }
            k--;//下一个兄弟
        }
        else
        {
            printf("2(");
            search(a[k]);//这个兄弟不乖，送进去分解了再出来
            printf(")");
            if (k > 1)//这位兄台不是 最后一位（k == 1）就得输出 +; 
            {
                printf("+");
            }
            k--;//下一个兄弟继续来啊
        }
    }
}
int main()
{
    int n = 0;
    cin >> n;
    search(n);
    return 0;
}

